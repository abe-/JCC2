import processing.opengl.*;
import wblut.math.*;
import wblut.processing.*;
import wblut.core.*;
import wblut.*;
import wblut.hemesh.*;
import wblut.geom.*;

HE_Mesh mesh;
WB_Render render;

void setup()
{
    size( 600, 600, OPENGL );
    
    // create the geodesic geometry
    HEC_Geodesic geo = new HEC_Geodesic().setRadius( 150 ).setLevel( 0 );
    
    // create a mesh from the geometry
    mesh = new HE_Mesh( geo );    
    
    // add some noise
    HEM_Noise noi = new HEM_Noise().setDistance( 10 );
    mesh.modify( noi );
    
    // extrude the mesh
    HEM_Extrude ext = new HEM_Extrude().setDistance( 10 ).setChamfer( 0.5 );
    mesh.modify( ext );
    
    // lattice
    HEM_Lattice lat = new HEM_Lattice().setWidth( 8 ).setDepth( 8 );
    mesh.modify( lat );
    
    // subdivide
    HES_CatmullClark cc = new HES_CatmullClark();
    mesh.subdivide( cc, 2 );
    
    // export the mesh
    // note that the last parameter sets the scale for exporting
    // The geodesic in this example has a radius of 150 pixels, which also
    // means a radius of 150mm. The final 3D print generated by this sketch will
    // be 300mm in size, so it will be too big to print on a small open-source printer.
    // If we lower the value of this to 0.1, the model will be scaled down to 10% of its
    // original size, and will be small enough to print.
    HET_Export.saveToSTL( mesh, sketchPath("mymodel.stl"), 0.1 );
    
    // create the renderer
    render = new WB_Render( this );
}

void draw()
{
    background( 0 );
    lights();

    translate( width/2, height/2 );
    rotateY( radians( frameCount ) );
    rotateX( radians( frameCount ) );
    
    // draw the faces of the mesh
    noStroke();
    fill( 255 );
    render.drawFaces( mesh );
    
    // draw the edges of the mesh
    stroke( 0 );
    noFill();
    render.drawEdges( mesh );    
}
